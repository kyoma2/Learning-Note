--邻接表结构--
Graph[Adjlist,vexnum,arcnum]
Adjlist[Vnode]
Vnode[data,*firstarc]
ArcNode[adjvex,*nextarc]
Vnode-->ArcNode;

--十字链表结构--
Graph[Adjlist,vexnum,arcnum]
Adjlist[Vnode]
Vnode[data,*firstinsame,*firstoutsame]
ArcNode[tail,head,*hlink,*tlink]
Vnode-->ArcNode;


--图的遍历--
--bfs--
"""完全当做层次遍历(队列),需注意不是连通图,所以需要套一层循环,扫描每个点是否被访问过."""
  void *bfs(Graph G,int v) {
      visit(v);  
      visited[v] = 1;
      EnQueue(v);
      While(!empty(Queue)){
          for (auto p = G.Adjlist[v].firstarc, p ,p=p->nextarc){
              n = p->adjvex;
              if (visited[n] == 0){
                  visit(n);
                  visited[n] = 1;
                  EnQueue(Q,n);
              }
          }
      }
  }
  
  
--dfs--
"""没什么特别的,递归逻辑就是([访问,找下一个点],repeat)"""
  void dfs(Graph G,int v) {
    visit(v);
    visited[v] = 1;
    for (auto p = G.adjlist[v].firstarc,p,p=p->nextarc){
        n = p->adjvex;
        if (visited[n] == 0){
            dfs(G,n);
        }
    }
}
  
--最小生成树--
1.prim(普里姆算法):找已有图最近的下一步
2.Kruskal(克鲁斯卡尔):找所有点之间的距离,把最短的距离两两相连,在把两个连好的看成一个点,再重复.(适合边少点多)

--最短路径--
指的是AB两点,带权路径最小的那条.


