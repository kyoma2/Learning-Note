--插入排序-- (从[2,n-1]开始,找合适的位置插入)
1.直接插入排序: o(n^2)从后往前有哨兵,局部有序.后比前大,则直接下一趟 (局部有序)(稳)
2.折半插入排序: o(nlogn) 有哨兵就是折半找插入点high+1. (局部有序)(稳)
3.希尔排序: o(n^1.3)  int d = d/2. (不稳)

--交换排序-- (从末尾开始两两比较交换)
1.冒泡排序:  o(n^2) 从后往前[n-1,0]，有flag(一趟没有交换,则已有序). (局部有序) (稳)
2.快速排序:  o(nlogn)  quicksort (int low,int high,int A[]) 递归. 找基准从后开始交换. 快慢取决于基准的选择. (不稳) 


--选择排序-- (找最小的,(交换)放入合适得位置)
1.简单选择排序: 永远o(n^2) 有序座位[0,n-1],每次找当前最小入座, (局部有序)(不稳(因为有交换的元素))
2.堆排序: 稳定时间o(nlogn) 利用小根堆的性质, 查找最小值只要h,o(logn),建堆o(n). (不稳)(因为有交换)

--归并排序和基数排序--
1.归并排序(2路):o(nlogn) [0,1,2,3,4] 递归到每2个元素,复制后半部分,归并合并. 
2.基数排序:o(d(n+r)) 多关键字排序,先收集,后分配.要用到队列长度为(r)

--plus--
基数排序不是基于比较的.
